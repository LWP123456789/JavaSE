# Day01笔记

> Java语言环境的关系(JDK、JRE、JVM关系)
>
> JDK = JRE + 开发工具集(例如Javac编译工具等)
>
> JRE = JVM + Java SE标准类库

## HelloWorld程序

```
class HelloChina {

	public static void main(String[] args){
		System.out.println("Hello World!");
	}

}
```

使用`javac HelloWorld.java`编译，使用`java HelloChina`执行字节码文件

public后的类名和文件名必须一致

> 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。
>
> **而且要求声明为public的类的类名必须与源文件名相同**

> 程序的入口是main()方法，格式是固定的。



## 关键字与保留字

定义：被Java语言赋予了特殊含义,用做专门用途的字符串(单词)

特点：关键字中所有字母都为小写

## 标识符

Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符

技巧：凡是自己可以起名字的地方都叫标识符

定义合法标识符规则：

由26个英文字母大小写，0-9 ，_或 **$** **组成**

**数字不可以开头。**

**不可以使用关键字和保留字，但能包含关键字和保留字。**

Java中严格区分大小写，长度无限制。

**标识符不能包含空格。**

### Java中的名称命名规范

包名：多单词组成时所有字母都小写: xxxyyyzzz

类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz(驼峰式)

变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz

常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

## 变量

```
class VariableTest {
	public static void main(String[] args) {
	//变量的定义
	int myAge = 12;
	//变量的使用
	System.out.println(myAge);
	
	//变量的声明
	int myNumber;
	//变量的赋值
	myNumber = 1001;
	
	System.out.println(myNumber);
	}
}
```

> **使用变量注意：**
>
> Java中每个变量必须先声明，后使用
>
> 使用变量名来访问这块区域的数据
>
> 变量的作用域：其定义所在的一对{ }内 
>
> 变量只有在其作用域内才有效
>
> 同一个作用域内，不能定义重名的变量

![image-20211023091209831](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023091209831.png)

# Day02笔记

## 变量

```
class VariableTest {
	public static void main(String[] args) {
	//变量的定义
	int myAge = 12;
	//变量的使用
	System.out.println(myAge);
	
	//变量的声明
	int myNumber;
	//变量的赋值
	myNumber = 1001;
	
	System.out.println(myNumber);
	}
}
```

> **使用变量注意：**
>
> Java中每个变量必须先声明，后使用
>
> 使用变量名来访问这块区域的数据
>
> 变量的作用域：其定义所在的一对{ }内 
>
> 变量只有在其作用域内才有效
>
> 同一个作用域内，不能定义重名的变量

![image-20211023091417288](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023091417288.png)

`byte:1字节=8bit位 范围 -128~127`

> https://blog.csdn.net/qq_23418393/article/details/57421688

```java
class VariableTest1 {
	//byte范围：-128~127
    byte b1 = 12;
    byte b2 = -128;
    //b2 = 128;//编译不通过
    System.out.println(b1);
    System.out.println(b2);
    //声明long型变量，必须以"1"或"L"结尾
    short s1 = 128;
    int i1 = 1234;
    long l1 = 3414234324L;
    System.out.println(l1);
    
    //浮点型
    //表示带小数点的数值
    //float表示数值的范围比long还大
    
    double d1 = 123.3;
    System.out.println(d1 + 1);
    //定义float类型变量时，变量要以"f"或"F"结尾
    float f1 = 12.3F;
    System.out.println(f1);
    //通常，定义浮点型变量时，选用double
    
    //字符型
    //定义char型变量，通常使用一对''，内部只能写一个字符
    char c1 = 'a';
    System.out.println(c1);
    
    //表示方法：1、声明一个字符 2、转义字符
    char c5 = '\n';//换行符
    // c5 = '\t' //制表符
    System.out.print("Hello"+c5);
    System.out.println("world")
        
    //布尔型：boolean
    //只能取两个值之一：true、false
    //常常在条件判断、循环结构中使用
    boolean bb1 = true;
    System.out.println(bb1);
    
    boolean isMarried = true;
    if(isMarried){
        System.out.println("祝你有一个温暖的家庭");
    }else{
        System.out.println("找个女朋友!");
    }
}
```

### 基本数据类型之间的运算规则：

前提：这里讨论的只是7种基本数据类型变量间的运算。不包含boolean类型的

1.自动类型提升：

结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型

`byte 、 char 、 short --> int --> long --> float --> double`

> 特别的：当byte、char、short三种类型的变量做运算时，结果为int型

```java
class VariableTest2 {
	public static void main(String[] args){
        byte b1 = 2;
        int i1 = 129;
        //编译不通过
        //byte b2 = b1 + i1;
        int i2 = b1 + i1;
        long l1 = b1 + i1;
        System.out.println(i2);
        
        float f = b1 + i1;
        System.out.println(f);
       
        char c1 = 'a';
        int i3 = 10;
        int i4 = c1 + i3;
        System.out.println(i4);
        
        short s2 = 10;
        //char c2 = c1 + s2;//编译不通过
        
        
    }
}
```

2.强制类型转换：

自动类型提升运算的逆运算

1.需要使用强转符：()

2.注意点：强制类型转换，可能导致精度损失。

```java
class VariableTest3 {
	public static void main(String[] args){
        
        double d1 = 12.3;
        
        int i1 = (int)d1;//截断操作
        System.out.println(i1);
        
        //没有精度损失
        long l1 = 123;
        short s2 = (short)l1;
        
        //精度损失举例2
        int i2 = 128;
        byte b = (byte)i2;
        System.out.println(b); //-128
    }
}
```

### 一些注意点：

```java
class VariableTest4 {
	public static void main(String[] args){
        
        //编码情况：
        long l = 123213;
        System.out.println(l);//编译通过,因为此时的l默认为int型
        
     	//编译失败：过大的整数
        //long l1 = 21332423235234123
        long l1 = 21332423235234123L;
        
        //编译失败
        //float f1 = 12.3;
        
        //2.编码情况2：
        //整型常量，默认类型为int型
        //浮点型常量，默认类型为double型
        byte b = 12;
        //byte b1 = b + 1;//编译失败
        
        //float f1 = b + 12.3;//编译失败 高精度不能直接转换为低精度
    }
}
```

### String类型变量的使用

1.`String`属于引用数据类型,翻译为：字符串

2.声明String类型变量时，使用一对""

3.`String`可以和8种基本数据类型变量做运算，且运算只能是连接运算 :+

4.运算的结果仍然是String类型

```java
class StringTest {
    public static void main(String[] args) {
    
        String s1 = "Hello World!";
        
        System.out.println(s1);
        
        String s2 = "a";
        String s3 = "";
        
        //char c = '';//编译不通过，至少放个空格
        
        int number = 1001;
        String numberStr = "学号：";
        String info = numberStr + number;// +：连接运算
        boolean b1 = true;
        String info1 = info + b1;
        System.out.println(info1);
        
        //练习1
        char c = 'a'; //97
        int num = 10;
        String str = "hello";
        System.out.println(c + num + str);//107hello
        System.out.println(c + str + num);//ahello10
        System.out.println(c + (num + str));//a10hello
        System.out.println((c + num) + str);//107hello
        System.out.println(str + num + c);//hello10a
        
        //练习2
        //* *
        System.out.println("*   *");
        System.out.println('*' + "\t" + '*');
        System.out.println('*' + ('\t' + "*"));
    }
}
```

### 运算符

```java
int a1 = 10;
int b1 = ++a1;
System.out.println("a1 = " + a1 + ",b1 = " + b1);

int a2 = 10;
int b2 = a2++;
System.out.println("a2 = " + a2 + ",b2 = " + b2);

//(前)++：先自增1，然后再运算
//(后)++：先运算，后自增1
```

赋值运算符

> +=、-=、*=、/=、%=

逻辑运算符

![image-20211023222827239](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023222827239.png)

“&”和“&&”的区别：

单&时，左边无论真假，右边都进行运算；

双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 

“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。 

异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。

理解：异或，追求的是“异”!



位运算符

![image-20211023223048618](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023223048618.png)

三元运算符

![image-20211023223138500](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023223138500.png)

> 凡是可以使用三元运算符的地方，都可以改写为if-else
>
> 反之，不成立。

### Scanner

如何从键盘获取不同类型的变量：需要使用Scanner类

具体实现步骤：

1.导包：import java.util.Scanner;

2.**`Scanner`**的实例化

3.调用Scanner类的相关方法，来获取指定类型的变量

```java
import java.util.Scanner;

class ScannerTest {
	public static void main(String[] args) {
		
        Scanner scan = new Scanner(System.in);
        
        int num = scan.nextInt();
        System.out.println(num);
        
	}
}
```

# Day03笔记

## 算法

判断素数算法(优化后)：

```java
class PrimeNumberTest {
    public static void main(String[] args) {
        
        boolean isFlag = true;
        
        //获取当前时间距离的毫秒数
        long start = System.currentTimeMillis();
        //优化二：对本身是质数的自然数是有效的。
        for(int j = 2; j <= Math.sqrt(i); j++) {
            
            if(i % j == 0){
                isFlag = false;
                break;//优化一：只对本身非素数的自然数是有效的。
            }
            
        }
        
        if(isFlag == true){
            System.out.println(i);
        }
        //重置isFlag
        isFlag = true;
        
    }
    //获取当前时间距离的毫秒数
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间: " + （end - start));
}
```

## break和continue

break：结束当前循环，默认跳出包裹此关键字最近的一层循环

continue：结束当次循环

## 数组

概述：

1.数组的理解：数组（Array），是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理

2.数据相关的概念：

> 数组名、元素、角标(下标、索引)

3.数组的特点：

1）.数组是有序排列的

2）.数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型

3）.创建数组对象会在内存中开辟一整块连续的空间

4）.数据的长度一旦确定，就不能修改

4.数组的分类： 

按照维度：一维数组、二维数组、三维数组、… 

按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)

5.一维数组的使用

①一维数组的声明和初始化

②如何调用数组的指定位置的元素

③如何获取数组的长度

④如何遍历数组

⑤数组元素的默认初始化值

⑥数组的内存解析

```java
public class ArrayTest {
    
    public static void main(String[] args){
        
        //1.一维数组的声明和初始化
        int num;//声明
        num = 10;//初始化
        int id = 1001; //声明 + 初始化
        
        int[] ids; //声明
        //1.1静态初始化:数组的初始化和数组元素的赋值操作同时进行
        ids = new int[]{1001,1002,1003,1004};
        //1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行
        String[] names = new String[5];
        
        //错误的写法：
        //int[] arr1 = new int[];
        //int[5] arr2 = new int[5];
        //int[] arr3 = new int[3]{1,2,3};
        
        //总结：数组一旦初始化完成，其长度就确定了。
        
        //2.如何调用数组的指定位置的元素:通过角标的方式调用。
        //数组的索引从0开始的，到数组的长度-1结束
        names[0] = "乐培";
        names[1] = "伟培";    
        names[2] = "学友";
        names[3] = "德华";
        names[4] = "子丹";
        //再names[5]就下标越界了
        
        //3.如何获取数组的长度
        //属性：length
        System.out.println(names.length);//5
        System.out.println(ids.length);//4
        
        //4.如何遍历数组
        for(int i = 0; i < names.length; i++){
            System.out.println(names[i]);
        }
        
        //5.数组元素的默认初始化值
        int[] arr = new int[4];
        for(int i = 0; i <　arr.length; i++){
            System.out.println(arr[i]);
        }
        
        //6.数组的内存解析
        //栈（stack）：存放局部变量
        //堆（heap）：new出来的结构：对象、数组
        //方法区：有常量池和静态域
    }
    
}
```

![image-20211024112604974](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211024112604974.png)

二维数组的使用

1.理解：

对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。

其实，从数组底层的运行机制来看，其实没有多维数组

2.二维数组的使用

①二维数组的声明和初始化

②如何调用数组的指定位置的元素

③如何获取数组的长度

④如何遍历数组

⑤数组元素的默认初始化值

⑥数组的内存解析

```java
public class ArrayTest2 {
    public static void main(String[] args) {
        //1.二维数组的声明和初始化
        int[] arr = new int[]{1,2,3};//一维数组
        //也是正确写法：
        int[] arr5 = {1,2,3,4,5};//类型推断
        //静态初始化
        int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
        //动态初始化1
        String[][] arr2 = new String[3][2];//声明一个三行两列的数组
        //动态初始化2
        String[][] arr3 = new String[3][];
        //错误的情况
        //String[][] arr4 = new String[][4];
        
        //正确：
        int[] arr4[] = new int[][]{{1,2,3},{4,5},{6,7,8}};
        
        //2.下标
        
        //3.获取数组的长度
        System.out.println(arr4.length);//3
        System.out.println(arr4[0].length);//3
        System.out.println(arr4[1].length);//2
        
        //4.如何遍历二维数组
        for(int i = 0; i < arr4.length; i++) {
            
            for(int j = 0;j < arr4[i].length; j++){
                System.out.println(arr4[i][j] + " ");
            }
            System.out.println();
        }
        
    }
}
```



```java
//数组元素的默认初始化值
public class ArrayTest3 {
    public static void main(String[] args) {
        int[][] arr = new int[4][3];
        System.out.println(arr[0]);//地址值
        System.out.println(arr[0][0]);//0
        
        System.out.println("***************");
        float[][] arr1 = new float[4][3];
        System.out.println(arr1[0]);//地址值;
        System.out.println(arr1[0][0]);//0.0
        
        System.out.println("***************");
        
        String[][] arr2 = new String[4][2];
        System.out.println(arr2[1]);//地址值
        System.out.println(arr2[1][1]);//null
        
        System.out.println("***************");
        String[][] arr3 = new String[4][];
        System.out.println(arr3[1]);//null
        System.out.println(arr3[1][0]);//报错 空指针异常
    }
}
```

杨辉三角

```java
1.第一行有1个元素，第n行有n个元素
2.每一行的第一个元素和最后一个元素都是1
3.从第三行开始，对于非第一个元素和最后一个元素的元素。即：
    yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];

public class YangHuiTest {
    public static void main(String[] args) {
        //1.声明并初始化二维数组
        int[][] yangHui = new int[10][];
        
        //2.给数组的元素赋值
        for(int i = 0; i < yangHui.length; i++) {
            yangHui[i] = new int[i + 1];
            
            //2.1给首末元素赋值
            yangHui[i][0] = yangHui[i][i] = 1;
            //2.2给每行的非首末元素赋值
            if(i > 1){
                for (int j = 1; j < yangHui[i].length-1;j++){
                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];
                }
            }
        }
        
        //3.遍历二维数组
        for(int i = 0; i < yangHui.length; i++) {
            for(int j = 0; j < yangHui[i].length; j++){
                System.out.println(yangHui[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

数组的复制

```java
/*
 * 使用简单数组
 * 拓展：修改题目，实现array2对array1数组的复制
 */
public class ArrayExer3 {
	public static void main(String[] args) {  //alt + /
		int[] array1,array2;
		
		array1 = new int[]{2,3,5,7,11,13,17,19};
		
		//显示array1的内容
		for(int i = 0;i < array1.length;i++){
			System.out.print(array1[i] + "\t");
		}
		
		//数组的复制:
		array2 = new int[array1.length];
		for(int i = 0;i < array2.length;i++){
			array2[i] = array1[i];
		}

		
		//修改array2中的偶索引元素，使其等于索引值(如array[0]=0,array[2]=2)
		for(int i = 0;i < array2.length;i++){
			if(i % 2 == 0){
				array2[i] = i;
			}
			
		}
		System.out.println();
		//打印出array1
		for(int i = 0;i < array1.length;i++){
			System.out.print(array1[i] + "\t");
		}
	}
}

```

数组的反转

```java
public class ArrayTest2 {
    
    public static void main(String[] args) {
        String[] arr = new String[]{"JJ","DD","MM","BB","GG","AA"};
        
        //数组的反转
        //方法一：
        for(int i = 0; i < arr.length / 2; i++) {
            String temp = arr[i];
            arr[i] = arr[arr.length - i - 1];
            arr[arr.length - i - 1] = temp;
        }
        
        //方法二：
        for(int i = 0,j = arr.length - 1; i < j; i++,j--) {
            String temp = arr[i];
			arr[i] = arr[i];
            arr[j] = temp;
        }
    } 
    
    //线性查找：
    String dest = "BB";
    
    boolean isFlag = true;
    
    for(int i = 0; i < arr.length; i++){
        
        if(dest.equals(arr[i])){
            System.out.println("找到了指定的元素，位置为：" + i);
            isFlag = false;
            break;
        }
    }
    if(isFlag) {
        System.out.println("很遗憾，没有找到哦！");
    }
	
    //二分法查找：
    //前提：所要查找的数组必须有序。
    int[] arr2 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
    
    int dest1 = -32;
    int head = 0;//初始的首索引
    int end = arr2.length - 1;//初始的末索引
    boolean isFlag1 = true;
    while(head <= end){
        int middle = (head + end)/2;
        
        if(dest1 == arr2[middle]){
            System.out.println("找到了指定的元素，位置为： " + i);
            isFlag1 = false;
            break;
        }else if(arr2[middle] > dest1){
            end = middle - 1;
        }else{
            head = middle + 1;
        }
    }
    
    if(isFlag1){
        System.out.println("没有找到")
    }
}
```

# Day04笔记

## Java面向对象

```java
/*
个人总结
Java面向对象学习的三条主线:
1.Java类及类的成员：属性、方法、构造器；代码块、内部类
2.面向对象的三大特征：封装性、继承性、多态性、（抽象性）
3.其它关键字：this、super、static、final、abstract、interface、package、import

面向对象的两个要素：类和对象
类：抽象概念；对象：实实在在的概念
面向对象程序设计的重点是类的设计
设计类，就是设计类的成员

属性 = 成员变量 = field = 域、字段
方法 = 成员方法 = 函数 = method
*/

//创建类的对象 = 类的实例化 = 实例化类
//类和对象的使用（面向对象思想落地的实现）
//1.创建类、设计类的成员
//2.创建类的对象
//3.通过"对象.属性"或"对象.方法"调用对象的结构
//测试类
public class PersonTest{
    public static void main(String[] args) {
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用对象的结构：属性、方法
        //调用属性：“对象.属性”
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法：“对象.方法”
        p1.eat();
        p1.sleep();
        p1.talk("Chinese");
        
    }
}

class Person{
    
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        System.out.println("人可以吃饭");
    }
    
    public void sleep(){
        System.out.println("人可以睡觉");
    }
    
    public void talk(String language){
        System.out.println("人可以说话，使用的是：" + language);
    }
    
}
```



# Day05笔记

```java
//如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）
//意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值
```

```java
//对象的内存解析
//堆：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
//栈：虚拟机栈。存储局部变量等
//方法区:存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

//类中属性的使用
/*
属性（成员变量） vs 局部变量
1.相同点：
	1.1定义变量的格式：数据类型 变量名  = 变量值
	1.2先声明，后使用
	1.3变量都有其对应的作用域

2.不同点：
	2.1在类中声明的位置的不同
	属性：直接定义在类的一对{}内
	局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
	
	2.2关于权限修饰符的不同
	属性：可以在声明属性时，指明其权限，使用权限修饰符。
	常用的权限修饰符：private、public、缺省、protected --->封装性
	局部变量：不可以使用权限修饰符.
	
	2.3默认初始化值ed情况：
	属性：类的属性，根据其类型，都有默认初始化值。
		整形（byte、short、int、long）:0
		浮点型（float、double）：0.0
		字符型（char）：0（或'\u0000'）
		布尔型（boolean）：false
		
		引用数据类型（类、数组、接口）：null
		
	局部变量：没有默认初始化值。
		意味着，我们在调用局部变量之前，一定要显式赋值。
		特别地，形参在调用时，我们赋值即可。
	
	2.4在内存中加载的位置：
	属性：加载到堆空间中（非static）
	局部变量：加载到栈空间

public class UserTest {
	public static void main(String[] args) {
		User u1 = new User();
		System.out.println(u1.name);
		System.out.println(u1.age);		
		System.out.println(u1.isMale);
        
        u1.talk("日语");
     
	}
}

class User {
	//属性（或成员变量）
	String name;
	int age;
	boolean isMale;
	
	public void talk(String language){//language：形参，也是局部变量
		System.out.println("使用" + language + "进行交流");
	}
	
	public void eat(){
		String food = "玫瑰饼";//局部变量
		System.out.println("云南人喜欢吃：" + food);
	}
}

*/
```

```java
/*
	类中方法的声明和使用
	
	方法：描述类应该具有的功能。
	
	1.方法的声明：(一定有下面的部分)
	权限修饰符 返回值类型 方法名（形参列表）{
		方法体
	}
	2.说明：
		2.1关于权限修饰符：默认方法的权限修饰符先都使用public
			Java规定的4种权限修饰符：private、public、缺省、protected --封装性细说
			
		2.2返回值类型：有返回值 vs 无返回值
			2.2.1 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使				  用return关键字来返回指定类型的变量或常量.
			2.2.2 如果方法无返回值，则方法声明时，使用void来表示，通常，没有返回值的方法中，				   就不使用return.但是，如果使用的话，只能"return;"表示结束此方法的意思。
		2.3方法名：属于标识符，遵循标识符的规则好规范，“见名知意”
		2.4形参列表：方法可以声明0个，1,个，或多个形参。
		2.5方法体：方法功能的体现
	
	3.return关键字的使用：
		1.适用范围：使用在方法体中
		2.作用：①结束方法
			   ②针对于有返回值的方法，使用"return 数据"方法返回所要的数据
		3.注意点：return关键字后面不可以声明执行语句
	
public class CustomerTest {
	public static void main(String[] args){
		Customer cust1 = new Customer();
		
		cust1.eat();
	}
}

//客户类
class Customer{

	//属性
	String name;
	int age;
	boolean isMale;
	
	//方法
	public void eat(){
		System.out.println("客户吃饭");
	}
	
	public void sleep(int hour){
		System.out.println("休息了" + hour + "个小时");
	}
	
	public String getName(){
		if(age > 18){
			return name;
		}else{
			return "Tom";
		}
	}
	
	public String getNation(String nation) {
		String info = "我的国际是：" + nation;
		return info;
	}
}
*/
```

```java
//求圆的面积
//测试类
public class CircleTest {
    public static void main(String[] arg) {
        
        Circle c1 = new Circle();
        
        System.out.println(c1.findArea());
    }
}

class Circle {
    //属性
    double radius;
    
    //求圆的面积
    public double findArea(){
        double area = Math.PI * radius *radius;
        return area;
    }
}
```

```java
//内存解析的说明
/*
	1.引用类型的变量，只可能存储两类值：null 或 地址值
*/
//对象数组
public class StudentTest {
    public static void main(String[] args) {
        //声明Student类型的数组
        Student[] stus = new Student[20];
        
        for(int i = 0; i < stus.length; i++){
            //给数组元素赋值
            stus[i] = new Student();
            //给Student对象的属性赋值
            stus[i].number = (i + 1);
            stus[i].state = Math.random() * (6 - 1 + 1) + 1;
            //年纪[1,6]
            //随机数a~b公式：int value = （int)(Math.random() * (b - a + 1) + a)
            //成绩[0,100]
            stus[i].score = (int)(Math.random() * (100 - 0 + 1));
        }
        
        //遍历学生数组
        for(int i = 0; i < stus.length; i++) {
            //System.out,println(stus[i].number + "," + stus[i].state
            //                   + "," + stus[i].score);
            System.out.println(stus[i].info());
        }
    }
}

class Student{
    int number;//学号
    int state;//年级
    int score;//成绩
    
    //显示学生信息的方法
    public String info(){
        return "学号：" + number + ",年纪：" + state + "，成绩：" + score;
    }
}
```

Math.random()方法的补充说明：

> Java中Math类的random()方法可以生成[0,1)之间的随机浮点数。而double类型数据强制转换成int类型，整数部分赋值给int类型变量，小数点之后的小数部分将会丢失。
>
> 如果要生成[0,n]的随机整数的话，只需要Math.random()乘以n+1，生成[0,n+1)的浮点数，再强制类型转换为int类型，只取其整数部分，即可得到[0,n]的整数。
>
> **生成的[m,n]之间的随机整数的方法：先生成[0,n-m]的随机整数，然后再加上m,即可得到[m,n]之间的随机整数。**

```java
//匿名对象的使用

public class InstanceTest {
    public static void main(String[] arg) {
        Phone p = new Phone();
//        p = null;
        System.out.println(p);
        
        p.sendEmail();
        p.playGame();
        
        //匿名对象
        /*
        new Phone().sendEmail();
        new Phone().playGame();
        new Phone().price = 1999;
        new Phone().showPrice();//0.0
        */
        
        PhoneMall mall = new PhoneMall();
//        mall.show(p);
        //匿名对象的使用
        mall.show(new Phone());
        
        /*匿名对象的使用
        1.理解：我们创建的对象，没有显式地赋给一个变量名。即为匿名对象
        2.特征：匿名对象只能调用一次。（一次性对象）
        3.使用：如上
        */
        
    }
}

class PhoneMall{
    
    public void show(Phone phone){
        //调用的是同一对象，phone式形参，局部变量放在栈中
        phone.sendEmail();
        phone.playGame();
    }
}

class Phone {
    double price;
    
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    
    public void playGame(){
        System.out.println("玩游戏");
    }
    
    public void showPrice(){
        
    }
}
```

```java
/*
自定义数组的工具类
*/
public class ArrayUtil {
    
    //求数组的最大值
    public int getMax(int[] arr){
        int maxValue = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(maxValue < arr[i]){
                maxValue = arr[i];
            }
        }
        return maxValue;
    }
    
    //求数组的最小值
    public int getMin(int[] arr){
        int minValue = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(minValue > arr[i]){
                minValue = arr[i];
            }
        }
        return minValue;
    }
    
    //求数组的总和
    public int getSum(int[] arr){
        int sum = 0;
        for(int i = 0; i < arr.length; i++){
            sum += arr[i];
        }
        return sum;
    }
    
    //求数组的平均值
    public int getAvg(int[] arr){
        //方法中调方法
        return getSum(arr)/arr.length;
    }
    
    //反转数组
    public void reverse(int[] arr){
        
    }
    
    //复制数组
    public int[] copy(int[] arr){
        int[] arr1 = new int[arr.length];
        for(int i = 0; i < arr1.length; i++){
            arr1[i] = arr[i];
        }
        return arr1;
    }
    
    //数组排序
    public void sort(int[] arr){
        //冒泡排序
        for(int i = 0; i < arr.length - 1; i++) {
            
            for(int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    //遍历数组
    public void print(int[] arr){
        for(int i = 0; i < arr.length; i++) {
            System.out.println(arr[i] + "\t");
        }
    }
    
    //查找指定元素
    public int getIndex(int[] arr,int dest){
        for (int i = 0; i < arr.length; i++) {
            
            if(dest == arr[i]) {
                return i;
            }
        }
        
        return -1;//返回一个负数，表示没有找到
    }
        
}
```

Array工具类测试：

```java
public class ArrayUtilTest {
    public static void main(String[] args) {
        
        ArrayUtil util = new ArrayUtil();
        int[] arr = new int[]{32,34,32,5,3,54,654,-98,0,-53,5};
        int max = util.getMax(arr);
        System.out.println("最大值为：" + max);
        
        System.out.println("排序前：");
        util.print(arr);
        
        util.sort(arr);
        System.out.println("排序后：");
        util.print(arr);
        
        System.out.println("查找：");
        int index = util.getIndex(arr,5);
        if(index >= 0){
            System.out.println("找到了，索引地址为：" + index);
        }else{
            System.out.println("未找到");
        }
    }
}
```

## 方法重载

重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。

```java
/*
方法的重载（overload）
1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
	"两同一不同"：同一个类、相同方法名
		参数列表不同：参数个数不同，参数类型不同
*/
public class OverLoadTest {
    public static void main(String[] args) {
        OverLoadTest test = new OverLoadTest();
        test.getSum(1,2);
    }
    public void getSum(int i,int j){
        System.out.println(i + j);
    }
    
    public void getSum(double d1,double d2){
        System.out.println(d1 + d2);
    }
    
    public void getSum(int i,String s){
        System.out.println("3");
    }
    
    public int getSum(int i,int j){
        return i + j;
    }
}
```

关于变量的赋值：

​	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。

​	如果变量是引用数据类型，此时赋值的是变量所保存的数据的**地址值**。

```java
/*
	方法的形参的传递机制：值传递
	1.形参：方法定义时，声明的小括号内的参数
	  实参：方法调用时，实际传递给形参的数据
	
	2.值传递机制：
	
*/ 
//基本数据类型
public class ValueTransferTest1 {
    public static void main(String[] args) {
        
        //交换两个变量的值得操作
        int m = 10;
        int n = 20;
        
        System.out.println("m = " + m + " , n = " + n);
        //交换两个变量的值得操作
        /*
        int temp = m;
        m = n;
        n = temp;
        */
        
        ValueTransferTest1 test = new ValueTransferTest1();
        test.swap(m,n);
        
        System.out.println("m = " + m + " , n = " + n);
        
    }
    
    public void swap(int m, int n){
        int temp = m;
        m = n;
        n = temp;
    }
}
```

> Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本
>
> （复制品）传入方法内，而参数本身不受影响。 
>
> 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
>
> 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参

将对象作为参数传递给方法

```java
public class Circle {
    double radius;//半径
    
    //求圆的面积
    public double findArea(){
        return Math.PI * radius * radius;
    }
}
public class PassObject {
    
    public static void main(String[] args) {
    	PassObject test = new PassObject();
    
        Circle c = new Circle();

        test.printAreas(c,5);

        System.out.println("now radiu is " + c.radius)	
        
    }
    
    public void printAreas(Circle c,int time){
        
        System.out.println("Radius\t\tArea");
        
        for(int i = 1; i <= time; i++){
        	//设置圆的半径
            c.radiu = i;
            double area = c.findArea();
            System.out.println(c,radius + "\t\t" + area);
        }
        
        c.radius = time +１；
        
    }
}
```

