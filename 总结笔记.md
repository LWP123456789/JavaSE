# Day01笔记

> Java语言环境的关系(JDK、JRE、JVM关系)
>
> JDK = JRE + 开发工具集(例如Javac编译工具等)
>
> JRE = JVM + Java SE标准类库

## HelloWorld程序

```
class HelloChina {

	public static void main(String[] args){
		System.out.println("Hello World!");
	}

}
```

使用`javac HelloWorld.java`编译，使用`java HelloChina`执行字节码文件

public后的类名和文件名必须一致

> 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。
>
> **而且要求声明为public的类的类名必须与源文件名相同**

> 程序的入口是main()方法，格式是固定的。



## 关键字与保留字

定义：被Java语言赋予了特殊含义,用做专门用途的字符串(单词)

特点：关键字中所有字母都为小写

## 标识符

Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符

技巧：凡是自己可以起名字的地方都叫标识符

定义合法标识符规则：

由26个英文字母大小写，0-9 ，_或 **$** **组成**

**数字不可以开头。**

**不可以使用关键字和保留字，但能包含关键字和保留字。**

Java中严格区分大小写，长度无限制。

**标识符不能包含空格。**

### Java中的名称命名规范

包名：多单词组成时所有字母都小写: xxxyyyzzz

类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz(驼峰式)

变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz

常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

## 变量

```
class VariableTest {
	public static void main(String[] args) {
	//变量的定义
	int myAge = 12;
	//变量的使用
	System.out.println(myAge);
	
	//变量的声明
	int myNumber;
	//变量的赋值
	myNumber = 1001;
	
	System.out.println(myNumber);
	}
}
```

> **使用变量注意：**
>
> Java中每个变量必须先声明，后使用
>
> 使用变量名来访问这块区域的数据
>
> 变量的作用域：其定义所在的一对{ }内 
>
> 变量只有在其作用域内才有效
>
> 同一个作用域内，不能定义重名的变量

![image-20211023091209831](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023091209831.png)

# Day02笔记

## 变量

```
class VariableTest {
	public static void main(String[] args) {
	//变量的定义
	int myAge = 12;
	//变量的使用
	System.out.println(myAge);
	
	//变量的声明
	int myNumber;
	//变量的赋值
	myNumber = 1001;
	
	System.out.println(myNumber);
	}
}
```

> **使用变量注意：**
>
> Java中每个变量必须先声明，后使用
>
> 使用变量名来访问这块区域的数据
>
> 变量的作用域：其定义所在的一对{ }内 
>
> 变量只有在其作用域内才有效
>
> 同一个作用域内，不能定义重名的变量

![image-20211023091417288](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023091417288.png)

`byte:1字节=8bit位 范围 -128~127`

> https://blog.csdn.net/qq_23418393/article/details/57421688

```java
class VariableTest1 {
	//byte范围：-128~127
    byte b1 = 12;
    byte b2 = -128;
    //b2 = 128;//编译不通过
    System.out.println(b1);
    System.out.println(b2);
    //声明long型变量，必须以"1"或"L"结尾
    short s1 = 128;
    int i1 = 1234;
    long l1 = 3414234324L;
    System.out.println(l1);
    
    //浮点型
    //表示带小数点的数值
    //float表示数值的范围比long还大
    
    double d1 = 123.3;
    System.out.println(d1 + 1);
    //定义float类型变量时，变量要以"f"或"F"结尾
    float f1 = 12.3F;
    System.out.println(f1);
    //通常，定义浮点型变量时，选用double
    
    //字符型
    //定义char型变量，通常使用一对''，内部只能写一个字符
    char c1 = 'a';
    System.out.println(c1);
    
    //表示方法：1、声明一个字符 2、转义字符
    char c5 = '\n';//换行符
    // c5 = '\t' //制表符
    System.out.print("Hello"+c5);
    System.out.println("world")
        
    //布尔型：boolean
    //只能取两个值之一：true、false
    //常常在条件判断、循环结构中使用
    boolean bb1 = true;
    System.out.println(bb1);
    
    boolean isMarried = true;
    if(isMarried){
        System.out.println("祝你有一个温暖的家庭");
    }else{
        System.out.println("找个女朋友!");
    }
}
```

### 基本数据类型之间的运算规则：

前提：这里讨论的只是7种基本数据类型变量间的运算。不包含boolean类型的

1.自动类型提升：

结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型

`byte 、 char 、 short --> int --> long --> float --> double`

> 特别的：当byte、char、short三种类型的变量做运算时，结果为int型

```java
class VariableTest2 {
	public static void main(String[] args){
        byte b1 = 2;
        int i1 = 129;
        //编译不通过
        //byte b2 = b1 + i1;
        int i2 = b1 + i1;
        long l1 = b1 + i1;
        System.out.println(i2);
        
        float f = b1 + i1;
        System.out.println(f);
       
        char c1 = 'a';
        int i3 = 10;
        int i4 = c1 + i3;
        System.out.println(i4);
        
        short s2 = 10;
        //char c2 = c1 + s2;//编译不通过
        
        
    }
}
```

2.强制类型转换：

自动类型提升运算的逆运算

1.需要使用强转符：()

2.注意点：强制类型转换，可能导致精度损失。

```java
class VariableTest3 {
	public static void main(String[] args){
        
        double d1 = 12.3;
        
        int i1 = (int)d1;//截断操作
        System.out.println(i1);
        
        //没有精度损失
        long l1 = 123;
        short s2 = (short)l1;
        
        //精度损失举例2
        int i2 = 128;
        byte b = (byte)i2;
        System.out.println(b); //-128
    }
}
```

### 一些注意点：

```java
class VariableTest4 {
	public static void main(String[] args){
        
        //编码情况：
        long l = 123213;
        System.out.println(l);//编译通过,因为此时的l默认为int型
        
     	//编译失败：过大的整数
        //long l1 = 21332423235234123
        long l1 = 21332423235234123L;
        
        //编译失败
        //float f1 = 12.3;
        
        //2.编码情况2：
        //整型常量，默认类型为int型
        //浮点型常量，默认类型为double型
        byte b = 12;
        //byte b1 = b + 1;//编译失败
        
        //float f1 = b + 12.3;//编译失败 高精度不能直接转换为低精度
    }
}
```

### String类型变量的使用

1.`String`属于引用数据类型,翻译为：字符串

2.声明String类型变量时，使用一对""

3.`String`可以和8种基本数据类型变量做运算，且运算只能是连接运算 :+

4.运算的结果仍然是String类型

```java
class StringTest {
    public static void main(String[] args) {
    
        String s1 = "Hello World!";
        
        System.out.println(s1);
        
        String s2 = "a";
        String s3 = "";
        
        //char c = '';//编译不通过，至少放个空格
        
        int number = 1001;
        String numberStr = "学号：";
        String info = numberStr + number;// +：连接运算
        boolean b1 = true;
        String info1 = info + b1;
        System.out.println(info1);
        
        //练习1
        char c = 'a'; //97
        int num = 10;
        String str = "hello";
        System.out.println(c + num + str);//107hello
        System.out.println(c + str + num);//ahello10
        System.out.println(c + (num + str));//a10hello
        System.out.println((c + num) + str);//107hello
        System.out.println(str + num + c);//hello10a
        
        //练习2
        //* *
        System.out.println("*   *");
        System.out.println('*' + "\t" + '*');
        System.out.println('*' + ('\t' + "*"));
    }
}
```

### 运算符

```java
int a1 = 10;
int b1 = ++a1;
System.out.println("a1 = " + a1 + ",b1 = " + b1);

int a2 = 10;
int b2 = a2++;
System.out.println("a2 = " + a2 + ",b2 = " + b2);

//(前)++：先自增1，然后再运算
//(后)++：先运算，后自增1
```

赋值运算符

> +=、-=、*=、/=、%=

逻辑运算符

![image-20211023222827239](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023222827239.png)

“&”和“&&”的区别：

单&时，左边无论真假，右边都进行运算；

双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 

“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。 

异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。

理解：异或，追求的是“异”!



位运算符

![image-20211023223048618](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023223048618.png)

三元运算符

![image-20211023223138500](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211023223138500.png)

> 凡是可以使用三元运算符的地方，都可以改写为if-else
>
> 反之，不成立。

### Scanner

如何从键盘获取不同类型的变量：需要使用Scanner类

具体实现步骤：

1.导包：import java.util.Scanner;

2.**`Scanner`**的实例化

3.调用Scanner类的相关方法，来获取指定类型的变量

```java
import java.util.Scanner;

class ScannerTest {
	public static void main(String[] args) {
		
        Scanner scan = new Scanner(System.in);
        
        int num = scan.nextInt();
        System.out.println(num);
        
	}
}
```

# Day03笔记

## 算法

判断素数算法(优化后)：

```java
class PrimeNumberTest {
    public static void main(String[] args) {
        
        boolean isFlag = true;
        
        //获取当前时间距离的毫秒数
        long start = System.currentTimeMillis();
        //优化二：对本身是质数的自然数是有效的。
        for(int j = 2; j <= Math.sqrt(i); j++) {
            
            if(i % j == 0){
                isFlag = false;
                break;//优化一：只对本身非素数的自然数是有效的。
            }
            
        }
        
        if(isFlag == true){
            System.out.println(i);
        }
        //重置isFlag
        isFlag = true;
        
    }
    //获取当前时间距离的毫秒数
    long end = System.currentTimeMillis();
    
    System.out.println("所花费的时间: " + （end - start));
}
```

## break和continue

break：结束当前循环，默认跳出包裹此关键字最近的一层循环

continue：结束当次循环

## 数组

概述：

1.数组的理解：数组（Array），是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理

2.数据相关的概念：

> 数组名、元素、角标(下标、索引)

3.数组的特点：

1）.数组是有序排列的

2）.数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型

3）.创建数组对象会在内存中开辟一整块连续的空间

4）.数据的长度一旦确定，就不能修改

4.数组的分类： 

按照维度：一维数组、二维数组、三维数组、… 

按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)

5.一维数组的使用

①一维数组的声明和初始化

②如何调用数组的指定位置的元素

③如何获取数组的长度

④如何遍历数组

⑤数组元素的默认初始化值

⑥数组的内存解析

```java
public class ArrayTest {
    
    public static void main(String[] args){
        
        //1.一维数组的声明和初始化
        int num;//声明
        num = 10;//初始化
        int id = 1001; //声明 + 初始化
        
        int[] ids; //声明
        //1.1静态初始化:数组的初始化和数组元素的赋值操作同时进行
        ids = new int[]{1001,1002,1003,1004};
        //1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行
        String[] names = new String[5];
        
        //错误的写法：
        //int[] arr1 = new int[];
        //int[5] arr2 = new int[5];
        //int[] arr3 = new int[3]{1,2,3};
        
        //总结：数组一旦初始化完成，其长度就确定了。
        
        //2.如何调用数组的指定位置的元素:通过角标的方式调用。
        //数组的索引从0开始的，到数组的长度-1结束
        names[0] = "乐培";
        names[1] = "伟培";    
        names[2] = "学友";
        names[3] = "德华";
        names[4] = "子丹";
        //再names[5]就下标越界了
        
        //3.如何获取数组的长度
        //属性：length
        System.out.println(names.length);//5
        System.out.println(ids.length);//4
        
        //4.如何遍历数组
        for(int i = 0; i < names.length; i++){
            System.out.println(names[i]);
        }
        
        //5.数组元素的默认初始化值
        int[] arr = new int[4];
        for(int i = 0; i <　arr.length; i++){
            System.out.println(arr[i]);
        }
        
        //6.数组的内存解析
        //栈（stack）：存放局部变量
        //堆（heap）：new出来的结构：对象、数组
        //方法区：有常量池和静态域
    }
    
}
```

![image-20211024112604974](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211024112604974.png)

二维数组的使用

1.理解：

对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。

其实，从数组底层的运行机制来看，其实没有多维数组

2.二维数组的使用

①二维数组的声明和初始化

②如何调用数组的指定位置的元素

③如何获取数组的长度

④如何遍历数组

⑤数组元素的默认初始化值

⑥数组的内存解析

```java
public class ArrayTest2 {
    public static void main(String[] args) {
        //1.二维数组的声明和初始化
        int[] arr = new int[]{1,2,3};//一维数组
        //也是正确写法：
        int[] arr5 = {1,2,3,4,5};//类型推断
        //静态初始化
        int[][] arr1 = new int[][]{{1,2,3},{4,5},{6,7,8}};
        //动态初始化1
        String[][] arr2 = new String[3][2];//声明一个三行两列的数组
        //动态初始化2
        String[][] arr3 = new String[3][];
        //错误的情况
        //String[][] arr4 = new String[][4];
        
        //正确：
        int[] arr4[] = new int[][]{{1,2,3},{4,5},{6,7,8}};
        
        //2.下标
        
        //3.获取数组的长度
        System.out.println(arr4.length);//3
        System.out.println(arr4[0].length);//3
        System.out.println(arr4[1].length);//2
        
        //4.如何遍历二维数组
        for(int i = 0; i < arr4.length; i++) {
            
            for(int j = 0;j < arr4[i].length; j++){
                System.out.println(arr4[i][j] + " ");
            }
            System.out.println();
        }
        
    }
}
```



```java
//数组元素的默认初始化值
public class ArrayTest3 {
    public static void main(String[] args) {
        int[][] arr = new int[4][3];
        System.out.println(arr[0]);//地址值
        System.out.println(arr[0][0]);//0
        
        System.out.println("***************");
        float[][] arr1 = new float[4][3];
        System.out.println(arr1[0]);//地址值;
        System.out.println(arr1[0][0]);//0.0
        
        System.out.println("***************");
        
        String[][] arr2 = new String[4][2];
        System.out.println(arr2[1]);//地址值
        System.out.println(arr2[1][1]);//null
        
        System.out.println("***************");
        String[][] arr3 = new String[4][];
        System.out.println(arr3[1]);//null
        System.out.println(arr3[1][0]);//报错 空指针异常
    }
}
```

杨辉三角

```java
1.第一行有1个元素，第n行有n个元素
2.每一行的第一个元素和最后一个元素都是1
3.从第三行开始，对于非第一个元素和最后一个元素的元素。即：
    yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];

public class YangHuiTest {
    public static void main(String[] args) {
        //1.声明并初始化二维数组
        int[][] yangHui = new int[10][];
        
        //2.给数组的元素赋值
        for(int i = 0; i < yangHui.length; i++) {
            yangHui[i] = new int[i + 1];
            
            //2.1给首末元素赋值
            yangHui[i][0] = yangHui[i][i] = 1;
            //2.2给每行的非首末元素赋值
            if(i > 1){
                for (int j = 1; j < yangHui[i].length-1;j++){
                    yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j];
                }
            }
        }
        
        //3.遍历二维数组
        for(int i = 0; i < yangHui.length; i++) {
            for(int j = 0; j < yangHui[i].length; j++){
                System.out.println(yangHui[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

数组的复制

```java
/*
 * 使用简单数组
 * 拓展：修改题目，实现array2对array1数组的复制
 */
public class ArrayExer3 {
	public static void main(String[] args) {  //alt + /
		int[] array1,array2;
		
		array1 = new int[]{2,3,5,7,11,13,17,19};
		
		//显示array1的内容
		for(int i = 0;i < array1.length;i++){
			System.out.print(array1[i] + "\t");
		}
		
		//数组的复制:
		array2 = new int[array1.length];
		for(int i = 0;i < array2.length;i++){
			array2[i] = array1[i];
		}

		
		//修改array2中的偶索引元素，使其等于索引值(如array[0]=0,array[2]=2)
		for(int i = 0;i < array2.length;i++){
			if(i % 2 == 0){
				array2[i] = i;
			}
			
		}
		System.out.println();
		//打印出array1
		for(int i = 0;i < array1.length;i++){
			System.out.print(array1[i] + "\t");
		}
	}
}

```

数组的反转

```java
public class ArrayTest2 {
    
    public static void main(String[] args) {
        String[] arr = new String[]{"JJ","DD","MM","BB","GG","AA"};
        
        //数组的反转
        //方法一：
        for(int i = 0; i < arr.length / 2; i++) {
            String temp = arr[i];
            arr[i] = arr[arr.length - i - 1];
            arr[arr.length - i - 1] = temp;
        }
        
        //方法二：
        for(int i = 0,j = arr.length - 1; i < j; i++,j--) {
            String temp = arr[i];
			arr[i] = arr[i];
            arr[j] = temp;
        }
    } 
    
    //线性查找：
    String dest = "BB";
    
    boolean isFlag = true;
    
    for(int i = 0; i < arr.length; i++){
        
        if(dest.equals(arr[i])){
            System.out.println("找到了指定的元素，位置为：" + i);
            isFlag = false;
            break;
        }
    }
    if(isFlag) {
        System.out.println("很遗憾，没有找到哦！");
    }
	
    //二分法查找：
    //前提：所要查找的数组必须有序。
    int[] arr2 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
    
    int dest1 = -32;
    int head = 0;//初始的首索引
    int end = arr2.length - 1;//初始的末索引
    boolean isFlag1 = true;
    while(head <= end){
        int middle = (head + end)/2;
        
        if(dest1 == arr2[middle]){
            System.out.println("找到了指定的元素，位置为： " + i);
            isFlag1 = false;
            break;
        }else if(arr2[middle] > dest1){
            end = middle - 1;
        }else{
            head = middle + 1;
        }
    }
    
    if(isFlag1){
        System.out.println("没有找到")
    }
}
```

# Day04笔记

## Java面向对象

```java
/*
个人总结
Java面向对象学习的三条主线:
1.Java类及类的成员：属性、方法、构造器；代码块、内部类
2.面向对象的三大特征：封装性、继承性、多态性、（抽象性）
3.其它关键字：this、super、static、final、abstract、interface、package、import

面向对象的两个要素：类和对象
类：抽象概念；对象：实实在在的概念
面向对象程序设计的重点是类的设计
设计类，就是设计类的成员

属性 = 成员变量 = field = 域、字段
方法 = 成员方法 = 函数 = method
*/

//创建类的对象 = 类的实例化 = 实例化类
//类和对象的使用（面向对象思想落地的实现）
//1.创建类、设计类的成员
//2.创建类的对象
//3.通过"对象.属性"或"对象.方法"调用对象的结构
//测试类
public class PersonTest{
    public static void main(String[] args) {
        //创建Person类的对象
        Person p1 = new Person();
        
        //调用对象的结构：属性、方法
        //调用属性：“对象.属性”
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法：“对象.方法”
        p1.eat();
        p1.sleep();
        p1.talk("Chinese");
        
    }
}

class Person{
    
    //属性
    String name;
    int age = 1;
    boolean isMale;
    
    //方法
    public void eat(){
        System.out.println("人可以吃饭");
    }
    
    public void sleep(){
        System.out.println("人可以睡觉");
    }
    
    public void talk(String language){
        System.out.println("人可以说话，使用的是：" + language);
    }
    
}
```



# Day05笔记

```java
//如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）
//意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值
```

```java
//对象的内存解析
//堆：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
//栈：虚拟机栈。存储局部变量等
//方法区:存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

//类中属性的使用
/*
属性（成员变量） vs 局部变量
1.相同点：
	1.1定义变量的格式：数据类型 变量名  = 变量值
	1.2先声明，后使用
	1.3变量都有其对应的作用域

2.不同点：
	2.1在类中声明的位置的不同
	属性：直接定义在类的一对{}内
	局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
	
	2.2关于权限修饰符的不同
	属性：可以在声明属性时，指明其权限，使用权限修饰符。
	常用的权限修饰符：private、public、缺省、protected --->封装性
	局部变量：不可以使用权限修饰符.
	
	2.3默认初始化值ed情况：
	属性：类的属性，根据其类型，都有默认初始化值。
		整形（byte、short、int、long）:0
		浮点型（float、double）：0.0
		字符型（char）：0（或'\u0000'）
		布尔型（boolean）：false
		
		引用数据类型（类、数组、接口）：null
		
	局部变量：没有默认初始化值。
		意味着，我们在调用局部变量之前，一定要显式赋值。
		特别地，形参在调用时，我们赋值即可。
	
	2.4在内存中加载的位置：
	属性：加载到堆空间中（非static）
	局部变量：加载到栈空间

public class UserTest {
	public static void main(String[] args) {
		User u1 = new User();
		System.out.println(u1.name);
		System.out.println(u1.age);		
		System.out.println(u1.isMale);
        
        u1.talk("日语");
     
	}
}

class User {
	//属性（或成员变量）
	String name;
	int age;
	boolean isMale;
	
	public void talk(String language){//language：形参，也是局部变量
		System.out.println("使用" + language + "进行交流");
	}
	
	public void eat(){
		String food = "玫瑰饼";//局部变量
		System.out.println("云南人喜欢吃：" + food);
	}
}

*/
```

```java
/*
	类中方法的声明和使用
	
	方法：描述类应该具有的功能。
	
	1.方法的声明：(一定有下面的部分)
	权限修饰符 返回值类型 方法名（形参列表）{
		方法体
	}
	2.说明：
		2.1关于权限修饰符：默认方法的权限修饰符先都使用public
			Java规定的4种权限修饰符：private、public、缺省、protected --封装性细说
			
		2.2返回值类型：有返回值 vs 无返回值
			2.2.1 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使				  用return关键字来返回指定类型的变量或常量.
			2.2.2 如果方法无返回值，则方法声明时，使用void来表示，通常，没有返回值的方法中，				   就不使用return.但是，如果使用的话，只能"return;"表示结束此方法的意思。
		2.3方法名：属于标识符，遵循标识符的规则好规范，“见名知意”
		2.4形参列表：方法可以声明0个，1,个，或多个形参。
		2.5方法体：方法功能的体现
	
	3.return关键字的使用：
		1.适用范围：使用在方法体中
		2.作用：①结束方法
			   ②针对于有返回值的方法，使用"return 数据"方法返回所要的数据
		3.注意点：return关键字后面不可以声明执行语句
	
public class CustomerTest {
	public static void main(String[] args){
		Customer cust1 = new Customer();
		
		cust1.eat();
	}
}

//客户类
class Customer{

	//属性
	String name;
	int age;
	boolean isMale;
	
	//方法
	public void eat(){
		System.out.println("客户吃饭");
	}
	
	public void sleep(int hour){
		System.out.println("休息了" + hour + "个小时");
	}
	
	public String getName(){
		if(age > 18){
			return name;
		}else{
			return "Tom";
		}
	}
	
	public String getNation(String nation) {
		String info = "我的国际是：" + nation;
		return info;
	}
}
*/
```

```java
//求圆的面积
//测试类
public class CircleTest {
    public static void main(String[] arg) {
        
        Circle c1 = new Circle();
        
        System.out.println(c1.findArea());
    }
}

class Circle {
    //属性
    double radius;
    
    //求圆的面积
    public double findArea(){
        double area = Math.PI * radius *radius;
        return area;
    }
}
```

```java
//内存解析的说明
/*
	1.引用类型的变量，只可能存储两类值：null 或 地址值
*/
//对象数组
public class StudentTest {
    public static void main(String[] args) {
        //声明Student类型的数组
        Student[] stus = new Student[20];
        
        for(int i = 0; i < stus.length; i++){
            //给数组元素赋值
            stus[i] = new Student();
            //给Student对象的属性赋值
            stus[i].number = (i + 1);
            stus[i].state = Math.random() * (6 - 1 + 1) + 1;
            //年纪[1,6]
            //随机数a~b公式：int value = （int)(Math.random() * (b - a + 1) + a)
            //成绩[0,100]
            stus[i].score = (int)(Math.random() * (100 - 0 + 1));
        }
        
        //遍历学生数组
        for(int i = 0; i < stus.length; i++) {
            //System.out,println(stus[i].number + "," + stus[i].state
            //                   + "," + stus[i].score);
            System.out.println(stus[i].info());
        }
    }
}

class Student{
    int number;//学号
    int state;//年级
    int score;//成绩
    
    //显示学生信息的方法
    public String info(){
        return "学号：" + number + ",年纪：" + state + "，成绩：" + score;
    }
}
```

Math.random()方法的补充说明：

> Java中Math类的random()方法可以生成[0,1)之间的随机浮点数。而double类型数据强制转换成int类型，整数部分赋值给int类型变量，小数点之后的小数部分将会丢失。
>
> 如果要生成[0,n]的随机整数的话，只需要Math.random()乘以n+1，生成[0,n+1)的浮点数，再强制类型转换为int类型，只取其整数部分，即可得到[0,n]的整数。
>
> **生成的[m,n]之间的随机整数的方法：先生成[0,n-m]的随机整数，然后再加上m,即可得到[m,n]之间的随机整数。**

```java
//匿名对象的使用

public class InstanceTest {
    public static void main(String[] arg) {
        Phone p = new Phone();
//        p = null;
        System.out.println(p);
        
        p.sendEmail();
        p.playGame();
        
        //匿名对象
        /*
        new Phone().sendEmail();
        new Phone().playGame();
        new Phone().price = 1999;
        new Phone().showPrice();//0.0
        */
        
        PhoneMall mall = new PhoneMall();
//        mall.show(p);
        //匿名对象的使用
        mall.show(new Phone());
        
        /*匿名对象的使用
        1.理解：我们创建的对象，没有显式地赋给一个变量名。即为匿名对象
        2.特征：匿名对象只能调用一次。（一次性对象）
        3.使用：如上
        */
        
    }
}

class PhoneMall{
    
    public void show(Phone phone){
        //调用的是同一对象，phone式形参，局部变量放在栈中
        phone.sendEmail();
        phone.playGame();
    }
}

class Phone {
    double price;
    
    public void sendEmail(){
        System.out.println("发送邮件");
    }
    
    public void playGame(){
        System.out.println("玩游戏");
    }
    
    public void showPrice(){
        
    }
}
```

```java
/*
自定义数组的工具类
*/
public class ArrayUtil {
    
    //求数组的最大值
    public int getMax(int[] arr){
        int maxValue = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(maxValue < arr[i]){
                maxValue = arr[i];
            }
        }
        return maxValue;
    }
    
    //求数组的最小值
    public int getMin(int[] arr){
        int minValue = arr[0];
        for(int i = 1; i < arr.length; i++){
            if(minValue > arr[i]){
                minValue = arr[i];
            }
        }
        return minValue;
    }
    
    //求数组的总和
    public int getSum(int[] arr){
        int sum = 0;
        for(int i = 0; i < arr.length; i++){
            sum += arr[i];
        }
        return sum;
    }
    
    //求数组的平均值
    public int getAvg(int[] arr){
        //方法中调方法
        return getSum(arr)/arr.length;
    }
    
    //反转数组
    public void reverse(int[] arr){
        
    }
    
    //复制数组
    public int[] copy(int[] arr){
        int[] arr1 = new int[arr.length];
        for(int i = 0; i < arr1.length; i++){
            arr1[i] = arr[i];
        }
        return arr1;
    }
    
    //数组排序
    public void sort(int[] arr){
        //冒泡排序
        for(int i = 0; i < arr.length - 1; i++) {
            
            for(int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    //遍历数组
    public void print(int[] arr){
        for(int i = 0; i < arr.length; i++) {
            System.out.println(arr[i] + "\t");
        }
    }
    
    //查找指定元素
    public int getIndex(int[] arr,int dest){
        for (int i = 0; i < arr.length; i++) {
            
            if(dest == arr[i]) {
                return i;
            }
        }
        
        return -1;//返回一个负数，表示没有找到
    }
        
}
```

Array工具类测试：

```java
public class ArrayUtilTest {
    public static void main(String[] args) {
        
        ArrayUtil util = new ArrayUtil();
        int[] arr = new int[]{32,34,32,5,3,54,654,-98,0,-53,5};
        int max = util.getMax(arr);
        System.out.println("最大值为：" + max);
        
        System.out.println("排序前：");
        util.print(arr);
        
        util.sort(arr);
        System.out.println("排序后：");
        util.print(arr);
        
        System.out.println("查找：");
        int index = util.getIndex(arr,5);
        if(index >= 0){
            System.out.println("找到了，索引地址为：" + index);
        }else{
            System.out.println("未找到");
        }
    }
}
```

## 方法重载

重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区别。

```java
/*
方法的重载（overload）
1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
	"两同一不同"：同一个类、相同方法名
		参数列表不同：参数个数不同，参数类型不同
*/
public class OverLoadTest {
    public static void main(String[] args) {
        OverLoadTest test = new OverLoadTest();
        test.getSum(1,2);
    }
    public void getSum(int i,int j){
        System.out.println(i + j);
    }
    
    public void getSum(double d1,double d2){
        System.out.println(d1 + d2);
    }
    
    public void getSum(int i,String s){
        System.out.println("3");
    }
    
    public int getSum(int i,int j){
        return i + j;
    }
}
```

关于变量的赋值：

​	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。

​	如果变量是引用数据类型，此时赋值的是变量所保存的数据的**地址值**。

```java
/*
	方法的形参的传递机制：值传递
	1.形参：方法定义时，声明的小括号内的参数
	  实参：方法调用时，实际传递给形参的数据
	
	2.值传递机制：
	
*/ 
//基本数据类型
public class ValueTransferTest1 {
    public static void main(String[] args) {
        
        //交换两个变量的值得操作
        int m = 10;
        int n = 20;
        
        System.out.println("m = " + m + " , n = " + n);
        //交换两个变量的值得操作
        /*
        int temp = m;
        m = n;
        n = temp;
        */
        
        ValueTransferTest1 test = new ValueTransferTest1();
        test.swap(m,n);
        
        System.out.println("m = " + m + " , n = " + n);
        
    }
    
    public void swap(int m, int n){
        int temp = m;
        m = n;
        n = temp;
    }
}
```

> Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本
>
> （复制品）传入方法内，而参数本身不受影响。 
>
> 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
>
> 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参

将对象作为参数传递给方法

```java
public class Circle {
    double radius;//半径
    
    //求圆的面积
    public double findArea(){
        return Math.PI * radius * radius;
    }
}
public class PassObject {
    
    public static void main(String[] args) {
    	PassObject test = new PassObject();
    
        Circle c = new Circle();

        test.printAreas(c,5);

        System.out.println("now radiu is " + c.radius)	
        
    }
    
    public void printAreas(Circle c,int time){
        
        System.out.println("Radius\t\tArea");
        
        for(int i = 1; i <= time; i++){
        	//设置圆的半径
            c.radiu = i;
            double area = c.findArea();
            System.out.println(c,radius + "\t\t" + area);
        }
        
        c.radius = time +１；
        
    }
}
```

# Day06笔记

## 面向对象的封装性

```java
/*
 * 面向对象的特征一：封装与隐藏     3W:what? why? how?
 * 一、问题的引入：
 *  当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到
 *  属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值
 *  加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）
 *  同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
 *  -->此时，针对于属性就体现了封装性。
 * 
 * 二、封装性的体现：
 * 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
 * 
 *  拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式   ...
 *  
 * 
 * 三、封装性的体现，需要权限修饰符来配合。
 * 1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public 
 * 2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
 * 3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
 *        修饰类的话，只能使用：缺省、public
 * 
 * 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。
 * 
 */
public class AnimalTest {
	public static void main(String[] args) {
		
		Animal a = new Animal();
		a.name = "大黄";
//		a.age = 1;
//		a.legs = 4;//The field Animal.legs is not visible
		
		a.show();
		
//		a.legs = -4;
//		a.setLegs(6);
		a.setLegs(-6);
		
//		a.legs = -4;//The field Animal.legs is not visible
		a.show();
		
		System.out.println(a.name);
		
	}
}


class Animal{
	
	String name;
	private int age;
	private int legs;//腿的个数
	
	//对属性的设置
	public void setLegs(int l){
		if(l >= 0 && l % 2 == 0){
			legs = l;
		}else{
			legs = 0;
//			抛出一个异常（暂时没有讲）
		}
	}
	
	//对属性的获取
	public int getLegs(){
		return legs;
	}
	
	
	public void eat(){
		System.out.println("动物进食");
	}
	
	public void show(){
		System.out.println("name = " + name + ",age = " + age + ",legs = " + legs);
	}
	
	//提供关于属性age的get和set方法
	public int getAge(){
		return age;
	}
	public void setAge(int a){
		age = a;
	}
	
}

//private class Dog{
//	
//}
```

四种权限修饰符：

![](E:\CSDN\JAVA\四种权限修饰符.png)

```java
public class Person {
    
    private int age;
    
    public void setAge(int a){
        if(a < 0 || a > 130){
            //throw new RuntimeException("传入的数据非法!");
            System.out.println("传入的数据非法!");
        }else{
            age = a;
        }
    }
    
    public int getAge(){
    	return age;
    }
}

/*
	在PersonTest类中实例化Person类的对象b,
	调用setAge()和getAge()方法，体会Java的封装性。
*/
public class PersonTest {
    public static void main(String[] args) {
        
        Person p1 = new Person();
        //p1.age = 1;编译不通过
        p1.setAge(12);
        
        System.out.println("年龄为：" + p1.getAge());
    }
}
```

## 构造器

类的结构之三：构造器（或构造方法、constructor）的使用

> 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器

```java
/*
 * 类的结构之三：构造器（或构造方法、constructor）的使用
 * construct：建设、建造。  construction:CCB    constructor:建设者
 * 
 * 一、构造器的作用：
 * 1.创建对象
 * 2.初始化对象的信息
 * 
 * 二、说明：
 * 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器
 * 2.定义构造器的格式：权限修饰符  类名(形参列表){}
 * 3.一个类中定义的多个构造器，彼此构成重载
 * 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
 * 5.一个类中，至少会有一个构造器。
 */
public class PersonTest {
	public static void main(String[] args) {
		//创建类的对象:new + 构造器
		Person p = new Person();
		
		p.eat();
		
		Person p1 = new Person("Tom");
		
		System.out.println(p1.name);
		
		
	}
}

class Person{
	//属性
	String name;
	int age;
	
	//构造器
	public Person(){
		System.out.println("Person().....");
	}
	
	public Person(String n){
		name = n;
		
	}
//	
	public Person(String n,int a){
		name = n;
		age = a;
	}

	
	//方法
	public void eat(){
		System.out.println("人吃饭");
	}
	
	public void study(){
		System.out.println("人可以学习");
	}
	
}
```

构造器三角形练习题：

```java
public class TriAngle {
    private double base;//底边长
    private double height;//高
    
    public TriAngle(){
        
    }
    
    public TriAngle(double b,double h){
        base = b;
        height = h;
    }
    
    public void setBase(double b){
        base b;
    }
    
    public double getBase(){
        return base;
    }
    
    public void setHeight(double h){
        height = h;
    }
    
    public double getHeight(){
        return height;
    }
    
}

public class TriAngleTest {
    public static void main(String[] args) {
        
        TriAngle t1 = new TriAngle();
        t1.setBase(2.0);
        t1.setHeight(2.4);
        //t1.base = 2.5;//The field TriAngle.base is not visible
        System.out.println("base : " + t1.getBase() + ",height : " + t1.getHeight());
        
    }
}
```

对赋值顺序验证

```java
/*
 * 总结：属性赋值的先后顺序
 * 
 * 
 * ① 默认初始化
 * ② 显式初始化
 * ③ 构造器中初始化
 * 
 * ④ 通过"对象.方法" 或 "对象.属性"的方式，赋值
 * 
 * 以上操作的先后顺序：① - ② - ③ - ④  
 * 
 */
public class UserTest {
	public static void main(String[] args) {
		User u = new User();
		
		System.out.println(u.age);
		
		User u1 = new User(2);
		
		u1.setAge(3);
		u1.setAge(5);
		
		System.out.println(u1.age);
	}
}

class User{
	String name;
	int age = 1;
	
	public User(){
		
	}
	
	public User(int a){
		age = a;
	}
	
	public void setAge(int a){
		age = a;
	}
	
}
```

**`JavaBean`**

`JavaBean`是一种Java语言写成的可重用组件。

```java
/*
所谓JavaBean，是指符合如下标准的Java类
 >类是公共的
 >有一个无参的公共的构造器
 >有属性，且有对应的get、set方法
*/
public class Customer {
    
    private int id;
    private String name;
    
    public Customer(){
        
    }
    
    public void setId(int i){
        id = i;
    }
    public int getId(){
        return id;
    }
    public void setName(String n){
        name = n;
    }
    public String getName(){
        return name;
    }
}
```

**this**

1.`this`可以用来修饰：属性、方法、构造器

2.`this`修饰属性和方法

this理解为：当前对象 或 当前正在创建的对象(构造器中)

在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象或当前正在创建的对象的属性或方法。但是，通常情况下，我们都选择省略"this."。

特殊情况下，如果方法的形参和类的属性同名时，我们必须显式地使用"this.变量"的方式，表面此变量是属性，而非形参。

3.`this`调用构造器

①我们在类的构造器中，可以显式地使用"this(形参列表)"方式，调用本类中的其他构造器

②构造器中不能通过"this(形参列表)"方式调用自己

③如果一个类中有n个构造器，则最多有n-1构造器中使用了"this(形参列表)"

④规定："this(形参列表)"必须声明在当前构造器的首行

⑤构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

```java
public class PersonTest {
    public static void main(String[] args) {
        
        Person p1 = new Person();
        
        p1.setAge(1);
        System.out.println(p1.getAge());
        
        p1.eat();
    }
}

class Person {
    
    private String name;
    private int age;
    
    public Person(){
        
    }
    
    public Person(String name){
        this.name = name;
    }
    
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
    
    public void eat(){
        System.out.println("人吃饭");
        this.study();
    }

    public void study(){
        System.out.println("人学习");
    }
}
```

练习

```java
public class Boy {
    private String name;
    private int age;
    
    public Boy() {
        
    }
    
    public Boy(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public void marry(Girl girl){
        System.out.println("我想娶" + girl.getName());
    }
    
    public void shout(){
        if(this.age >= 22){
            System.out.println("你可以去合法登记结婚了!");
        }else{
            System.out.println("先多谈谈恋爱~");
        }
    }
}

public class Girl{
    
    private String name;
    private int age;
    
    public Girl(String name,int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName(){
        return name;
    }
    
    public void setName(String name){
        this.name = name;
    }
    
    public void marry(Boy boy){
        System.out.println("我想嫁给" + boy.getName());
        boy.marry(this);//this代表当前对象，也就是girl这个对象.
    }
    
    /*
    @Description 比较两个对象的大小
    */
    public int compare(Gril girl){
        //if(this.age > girl.age){
        //    return 1;
        //}else if(this.age < girl.age){
        //    return -1;
        //}else{
        //    return 0;
        //}
        
        return this.age - girl.age;
    }
}

public class BoyGirlTest {
    public static void main(String[] args) {
        
        Boy boy = new Boy("乐培",21);
        boy.shout();
        
        Girl girl = new Girl("nana",18);
        girl.marry(boy);
        
        Girl1 girl1 = new Girl("lili",19);
        int compare = girl.compare(girl1);
        if(compare > 0){
            System.out.println(girl.getName() + "大");
        }else if(compare  < 0){
            System.out.println(girl1.getName() + "大");
        }else{
            System.out.println("一样大");
        }
    }
}
```

# Day07笔记

## 继承

继承性的好处：

① 减少了代码的冗余，提高了代码的复用性

② 便于功能的扩展

③ 为之后多态性的使用，提供了前提



继承性的格式：class A extends B{

​	A:子类、派生类、subclass

​	B:父类、超类、基类、superclass



​	体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明所有的属性和方法。

}

> 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为**封装性**的影响，使得子类不能直接调用父类的结构而已。
>
> 子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的**拓展**。
>
> 子类和父类的关系，不同于子集和集合的关系。
>
> extends:延展、拓展

Java中关于继承性的一些规定：

​	1.一个类可以被多个子类继承

​	2.`Java`类的单继承性: 一个类只能有一个父类

​    3.子父类是相对的概念

​	4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类

​    5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。



> 1.如果我们没有显式的声明一个类的父类的话，则此类继承于`java.lang.Object`类
>
> 2.所有的`java`类（除`java.lang.Object`类之外）都直接或间接的继承于`java.lang.Object`类
>
> 3.意味着，所有的`java`类具有`java.lang.Object`类声明的功能

### 方法的重写

定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也成为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。

> **要求**：
>
> 1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
>
> 2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
>
> 3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
>
>    子类不能重写父类中声明为private权限的方法
>
> 4. 子类方法抛出的异常不能大于父类被重写方法的异常

# Day08笔记

## super

```java
/*
	super关键字的使用
	1.super理解为：父类的
	2.super可以用来调用：属性、方法、构造器
	
	3.super的使用
		3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
		3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性
		3.3 特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。
	4.super调用构造器
		4.1 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
		4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行!
		4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
		4.4 当构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器
		4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器
*/

public class Person {
    String name;
    int age;
    int id = 1001;//身份证号
    
    public Person() {
        
    }
    
    public Person(String name){
        this.name = name;
    }
    
    public Person(String name,int age){
        this(name);
        this.age = age;
    }
    
    public void eat(){
        System.out.println("人，吃饭");
    }
    
    public void walk(){
        System.out.println("人，走路");
    }
}

public class Student extends Person{
    
    String major;
    int id = 1002;//学号
    
    public Student(){
        
    }
    public Student(String major){
        this.major = major;
    }
    
    public Student(String name,int age,String major){
        //this.name = name;
        //this.age = age;
        super(name,age);
        this.major = major;
    }
    
    @Override
    public void eat() {
        System.out.println("学生，多吃有营养的食物");
    }
    
    public void study() {
        System.out.println("学生，学习知识");
    }
    
    public void show() {
        System.out.println("name = " + this.name + ", age = " + super.age);
    }
}

public class SuperTest {
    public static void main(String[] args) {
        
        Student s = new Student();
        s.show();
        
        System.out.println();
        
        S.study();
        
        Student s1 = new Student("Tom",21,"IT");
        s1.show();
    }
}
```

> 属性不会出现覆盖

**调用父类的构造器** 

子类中所有的构造器**默认**都会访问父类中**空参数**的构造器 

当父类中没有空参数的构造器时，子类的构造器必须通过**this(参数列表)**或者**super(参数列表)**语句指定调用本类或者父类中相应的

构造器。同时，只能”二选一”，且必须放在构造器的首行 

`如果子类构造器中既未显式调用父类或本类的构造器，且父类中又`

`没有无参的构造器，则**编译出错`**

```java
/*
 * 子类对象实例化的全过程
 * 
 * 1. 从结果上来看：（继承性）
 * 		子类继承父类以后，就获取了父类中声明的属性或方法。
 *      创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
 * 
 * 2. 从过程上来看：
 * 		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...
 *    直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有
 *    父类中的结构，子类对象才可以考虑进行调用。
 *    
 *  
 * 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。
 * 
 */
```

## 多态性

```java
package top.lep101.java;

/**
 * 编译看左，运行看右
 *
 * 面向对象特征之三：多态性
 *
 * 1.理解多态性：可以理解为一个事物的多种邢台。
 * 2.何为多态性：
 *     对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
 * 3.多态的使用：虚拟方法调用
 *     有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际运行的是子类重写父类的方法。
 *     总结：编译，看左边；运行，看右边。
 * 4.多态性的使用前提：① 类的继承关系 ② 要有方法的重写
 * 5.对象的多态性,只适用于方法，不适用于属性（编译和运行都看左边）
 */
public class PersonTest {
    public static void main(String[] args) {

        Person p1 = new Person();
        p1.eat();

        Man man = new Man();
        man.eat();
        man.age = 25;
        man.earnMoney();

        //***************************************************
        //对象的多态性：父类的引用指向子类的对象
        Person p2 = new Man();

        Person p3 = new Woman();

        //多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法  ---虚拟方法调用
        p2.eat();
        p2.walk();



    }
}

public class Man extends Person{

    boolean isSmoking;

    @Override
    public void walk() {
        System.out.println("handsome walking");
    }

    @Override
    public void eat() {
        System.out.println("eat more");
    }

    public void earnMoney(){
        System.out.println("earning Money");
    }

}

public class Woman extends Person{

    boolean isBeauty;

    public void goShopping(){
        System.out.println("goShopping");
    }

    @Override
    public void eat() {
        System.out.println("eat less");
    }

    @Override
    public void walk() {
        System.out.println("beautifully walk");
    }
}

public class Person {
    String name;
    int age;

    public void eat(){
        System.out.println("eating");
    }

    public void walk(){
        System.out.println("walking");
    }
}

//多态性的使用举例一：
//可见多态性省去了很多方法重载的过程
public class AnimalTest {

    public static void main(String[] args) {
        AnimalTest test = new AnimalTest();
        test.func(new Dog());

        test.func(new Cat());
    }

    public void func(Animal animal){
        animal.eat();
        animal.shout();
    }
}

class Animal {
    public void eat(){
        System.out.println("动物：进食");
    }

    public void shout(){
        System.out.println("动物：叫");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }

    @Override
    public void shout() {
        System.out.println("汪汪汪");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }

    @Override
    public void shout() {
        System.out.println("喵喵喵");
    }
}

```

下转型

有了对象的多态性以后，内存中实际上是加载了类特有的属性和方法的，但是由于变量声明为父亲类型，导致编译时，只能调用父类声明的属性和方法，子类持有的属性和方法不能调用。



//使用强制类型转换符实现向下转型

```
Man m1 = (Man)p1;
m1.earnMoney();
m1.isSmoking = true;
```

instanceof关键字的使用

a instance A ： 判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。

使用情景：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型，如果返回false，不进行向下转型。



如果

```java
if(p1 instanceof Woman){
    Woman w1 = (Woman)p1;
    w1.goShopping();
    System.out.println("******Woman********");
}
if(p1 instanceof Man){
    Man m1 = (Man)p1;
	m1.earnMoney();
    System.out.println("******Man********");
}
```

//练习

```java
//问题一：编译时通过，运行时不通过
Person p3 = new Woman();
Man m3 = (Man)p3;

//问题二：编译通过，运行时也通过
Object obj = new Woman();
Person p = (Person)obj
    
//问题三：编译不通过
    Man m5 = new Woman();
/*
1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量，编译运行都看左边
*/
```

```java
/**
 * java.lang.Object类
 * 1.Object类是所有Java类的根父类
 * 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
 * 3.Object类中的功能（属性、方法）就具有通用型。
 *      属性：无
 *      方法：equals()/toString()/getClass()/hashCode()/clone()/finalize()/wait()/notify()/notifyAll()
 * 4.Object类只声明了一个空参的构造器
 *
 * 面试题：final、finally、finalize的区别？
 * 前俩关键字，后一个垃圾回收，三者之间无关系
 */
public class ObjectTest {
    public static void main(String[] args) {

        Order order = new Order();
        System.out.println(order.getClass().getSuperclass());

    }
}

class Order{

}
```

==运算符比较基本数据类型和引用数据类型

```java
/**
 * 面试题： == 和 equals() 区别
 *
 * 一、回顾 == 的使用
 * ==：运算符
 * 1.可以使用在基本数据类型变量和引用数据类型变量中
 * 2.如果比较的基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
 *   如果比较的引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体
 *
 * 二、equals()方法的使用
 * 1.是一个方法，而非运算符
 * 2.只能使用于引用数据类型
 * 3.Object类中equals()的定义：
 *      public boolean equals(Object obj) {
 *          return (this == obj);
 *      }
 *      说明：Object类中定义的equals()和==的作用是相同的；比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体
 * 4.像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同
 * 5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写。
 *   重写的原则：比较两个对象的实体内容是否相同
 */
public class EqualsTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 10;
        double d = 10.0;
        System.out.println(j == i);
        System.out.println(i == d);

        char c = 10;
        System.out.println(i == c);


    }
}

```

# Day09笔记

## toString()

```java
/*
Object类中toString()的使用

1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
2.Object类中toString()的定义：
	public String toString() {
		return getClass().getName() + "@" + Integer.toHexString(hashCode());
	}
3.像String、Date、File、包装类等都重写了Object类中的toString()方法
  使得在调用对象的toString()时，返回"实体内容"信息
  
4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"
*/
public class ToStringTest {
	public static void main(String[] args) {
        
        Customer cust1 = new Customer("Tom",21);
        System.out.println(cust1.toString());
        System.out.println(cust1);
        
        String str = new String("LWP");
        System.out.println(str);//LWP
        
		Date date = new Date(4534534534543L);
        System.out.println(date.toString());//Mon Sep 11 08:55:34 GMT+08:00......
    }
}
```

测试练习

```java
package top.lep101.java3;

/**
 * 写一个测试类，创建两个Circle对象，判断其颜色是否相等;
 */
public class CircleTest {
    public static void main(String[] args) {

        Circle circle1 = new Circle(2.3);
        Circle circle2 = new Circle(new String("white"),2.0,3.3);

        System.out.println("颜色是否相等：" + circle1.getColor().equals(circle2.getColor()));

        System.out.println("半径是否相等：" + circle1.equals(circle2));

        System.out.println(circle1);
        System.out.println(circle2.toString());
    }
}

package top.lep101.java3;

public class Circle extends GeometricObject {

    private double radius;

    public Circle() {
        radius = 1.0;
    }

    public Circle(double radius) {
        this.radius = radius;
    }

    public Circle(String color, double weight, double radius) {
        super(color, weight);
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    //求圆的面积
    public double findArea(){
        return 3.14 * radius * radius;
    }

    //比较两个圆的半径是否相等，如相等，返回true

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof Circle){
            Circle c = (Circle) obj;
            return this.radius == c.radius;
        }

        return false;
    }

    @Override
    public String toString() {
        return "Circle [radius=" + radius + "]";
    }
}

package top.lep101.java3;

public class GeometricObject {

    protected String color;
    protected double weight;

    public GeometricObject() {
        this.color = "white";
        this.weight = 1.0;
    }

    public GeometricObject(String color, double weight) {
        this.color = color;
        this.weight = weight;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }
}

```

> `Java`中的JUnit单元测试
>
> 步骤：
>
> 1.选中当前工程 - 右键选择： build path - add libraries - JUnit4 - 下一步
>
> 2.创建Java类，进行单元测试。
>
> 此时的Java类要求：①此类是public的 ②此类提供公共的无参的构造器
>
> 3.此类中声明单元测试方法。
>
> 此时的单元测试方法：**方法的权限是public，没有返回值类型，没有形参**
>
> 4.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test;
>
> 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。
>
> 6.写完代码以后，测试

```java
public class JUnitTest {
    
    @Test
    public void testEquals(){
        String s1 = "MM";
        String s2 = "MM";
        System.out.println(s1.equals(s2));
    }
}
```

## 包装类

针对八种基本数据类型定义相应的引用类型—包装类（封装类）

有了类的特点，就可以调用类中的方法，Java才是真正的面向对象

![](E:\CSDN\JAVA\包装类.png)

基本类型、包装类与String类间的转换

![](E:\CSDN\JAVA\基本数据类型_包装类_String类之间的关系.png)

```java
/*
包装类的使用:
1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征

2.掌握的：基本数据类型、包装类、String三者之间的相互转换
*/
public class WrapperTest {
    
    //基本数据类型 --->包装类：调用包装类的构造器
    @Test
    public void test(){
        int num1 = 10;
        //System.out.println(num1.toString());
        Integer in1 = new Integer(num1);
        System.out.println(in1.toString());
        
        Integer in2 = new Integer("123");
        System.out.println(in2.toString());
        
        //报异常
        //Integer in3 = new Integer("123abc");
        //System.out.println(in3.toString());        
        
        Float f1 = new Float(12.3f);
        Float f2 = new Float("12.3");
        System.out.println(f1);
        System.out.println(f2);
        
        Boolean b1 = new Boolean(true);
        Boolean b2 = new Boolean("true");
        System.out.println(b2);//true
        Boolean b3 = new Boolean("true123");
        System.out.println(b3);//false
    }
    
    //包装类 --->基本数据类型：调用包装类的xxxValue()
    @Test
    public void test2(){
        Integer in1 = new Integer(12);
        
        int i1 = in1.intValue();
        System.out.println(i1 + 1);
        
        Float f1 = new Float(12.3);
        float f2 = f1.floatValue();
        System.out.println(f2 + 1);
    }
    
    /*
    JDK5.0新特性：自动装箱与自动拆箱
    */
    @Test
    public void test3(){
        int num1 = 10;
        //基本数据类型 --> 包装类的对象
        method(num1);//
        
        //自动装箱：
        int num2 = 10;
        Integer in1 = num2;//自动装箱
        
        boolean b1 = true;
        Boolean b2 = b1;//自动装箱
        
        //自动拆箱：包装类 --> 基本数据类型
        System.out.println(in1.toString());
        
        int num3 = in1;//自动拆箱
    }
    
    public void method(Object obj){
        System.out.println(obj);
    }
    
    //基本数据类型、包装类 --> String类型
    @Test
    public void test4(){
        
        int num1 = 10;
        //方式1：连接运算
        String str1 = num1 + "";
        //方式2：
        float f1 = 12.3f;
        String str2 = String.valueOf(f1);//"12.3"
        //以下例子体现了自动拆箱
        Double d1 = new Double(12.4);
        String str3 = String.valueOf(d1);
        System.out.println(str2);
        System.out.println(str3);
    }
    
    //String类型 --> 基本数据类型、包装类:调用包装类的parseXxx()
    @Test
    public void test5(){
        String str1 = "123";
        //错误的情况：
        //int num1 = (int)str1;
        //Integer in1 = (Integer)str1;
        
        int num2 = Integer.parseInt(str1);
        System.out.println(num2 + 1);
        
        String str2 = "true";
        boolean b1 = Boolean.parseBoolean(str2);
        System.out.println(b1);
    }
}
```

面试题

```java
public class InterviewTest {
    @Test
    public void test1() {
        Object o1 = true ? new Integer(1) : new Double(2.0);
        //三元运算符两表达式为同种类型
        //三元运算符会进行自动类型提升
        System.out.println(o1);//1.0
        //自动拆箱
        //包装类重写了toString()方法输出实体内容而不是地址
    }
    @Test
    public void test2(){
        Object o2;
        if(true)
            o2 = new Integer(1);
        else
            o2 = new Double(2.0);
        System.out.println(o2);//1
    }
    
    @Test
    public void test3() {
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);//false 比的是地址
        
        //Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],
        //保存了从-128~127范围的整数，如果我们使用自动装箱的方式，给Integer赋值的范围在
        //-128~127范围内时，可以直接使用数组中的元素。不用再去new了。
        
        Integer m = 1;
        Integer n = 1;
        System.our.println(m == n);//true
        
        Integer x = 128;//相当于new了一个Integer对象
        Integer y = 128;//相当于new了一个Integer对象
        System.out.println(x == y);//false
    }
}
```

测试练习

```java
package top.lep101.java3;

import java.util.Scanner;
import java.util.Vector;

public class ScoreTest {
    public static void main(String[] args) {
        //1.实例化Scanner，用于从键盘获取学生成绩
        Scanner scan = new Scanner(System.in);
        //2.创建Vector对象，Vector v = new Vector();相当于原来的数组
        Vector v = new Vector();
        //3.通过for(;;)或while(true)方式，给Vector中添加数组
        int maxScore = 0;
        for (;;){
            System.out.println("请输入学生成绩（以负数代表输入结束）");
            int score = scan.nextInt();
            //3.2当输入是负数时，跳出循环
            if (score < 0) {
                break;
            }
            if (score > 100){
                System.out.println("输入的数据非法，请重新输入");
                continue;
            }
            //3.1添加操作：v.addElement(Object obj)
            /*jdk5.0之前：
            Integer inScore = new Integer(score);
            v.addElement(inScore);//多态*/
            //jdk5.0之后:
            v.addElement(score);//自动装箱
            //4.获取学生成绩的最大值
            if (maxScore < score){
                maxScore = score;
            }
        }
        char level;
        //5.遍历Vector,得到每个学生的成绩，并于最大成绩比较，得到每个学生的等级。
        for (int i = 0; i < v.size(); i++){
            Object obj = v.elementAt(i);
            //jdk5.0后
            int score = (int)obj;

            if (maxScore - score <= 10){
                level = 'A';
            }else if (maxScore - score <= 20) {
                level = 'B';
            }else if (maxScore - score <= 30) {
                level = 'C';
            }else{
                level = 'D';
            }

            System.out.println("student-" + i + " score is " + score+ ",level is " + level);
        }
    }
}
```

